import { Controller } from "@hotwired/stimulus"
import consumer from "../channels/consumer"

/**
 * üèóÔ∏è <%= file_name.camelize %> Controller - Handles WebSocket + UI for <%= file_name.humanize.downcase %>
 * 
 * ADD YOUR UI HERE:
 * - static targets = ["messageInput", "messagesContainer", "sendButton"]
 * - Add UI methods like sendMessage(), displayMessage()
 * - Use channelReceived() to handle real-time updates
 * 
 * DON'T create separate controllers - extend this one!
 * HTML: <div data-controller="<%= file_name.dasherize %>">...</div>
 */
export default class extends Controller<HTMLElement> {
  static targets = [
    // üí° EXAMPLE: Common targets for your UI
    // "messageInput",     // <input data-<%= file_name.dasherize %>-target="messageInput">
    // "messagesContainer" // <div data-<%= file_name.dasherize %>-target="messagesContainer">
  ] as const

  static values = {
    // Add your values here, e.g.:
    // roomId: String,
    // userId: String
  }

  // Declare your targets and values
  // declare readonly messageInputTarget: HTMLInputElement
  // declare readonly messagesContainerTarget: HTMLElement
  // declare readonly roomIdValue: string

  private subscription: any = null
  private isConnected: boolean = false

  connect(): void {
    console.log("<%= file_name.camelize %> controller connected")
    this.createSubscription()
  }

  disconnect(): void {
    console.log("<%= file_name.camelize %> controller disconnected")
    this.destroySubscription()
  }

  // üéÆ ADD YOUR UI METHODS HERE
  // Example: data-action="click-><%= file_name.dasherize %>#sendMessage"
  sendMessage(event: Event): void {
    // TODO: Get input content, send via WebSocket, clear form
    // Example: this.performAction('send_message', { content: input.value })
  }

  // üí° UI HELPER METHODS - Add methods to update your interface
  private displayMessage(messageData: any): void {
    // TODO: Create message HTML element and add to container
    // TODO: Scroll to bottom, update UI state
  }

  // WebSocket subscription management
  private createSubscription(): void {
    if (this.subscription) return

    this.subscription = consumer.subscriptions.create(
      {
        channel: "<%= channel_name %>",
        // Add subscription parameters here, e.g.:
        // room_id: this.roomIdValue
      },
      {
        connected: this.channelConnected.bind(this),
        disconnected: this.channelDisconnected.bind(this),
        received: this.channelReceived.bind(this)
      }
    )
  }

  private destroySubscription(): void {
    if (this.subscription) {
      this.subscription.unsubscribe()
      this.subscription = null
      this.isConnected = false
    }
  }

  // WebSocket event handlers
  private channelConnected(): void {
    console.log("Connected to <%= channel_name %>")
    this.isConnected = true

    // Restore any disabled buttons when connecting
    if (typeof window.restoreButtonStates === 'function') {
      window.restoreButtonStates()
    }

    // Add your connection logic here
    this.onConnected()
  }

  private channelDisconnected(): void {
    console.log("Disconnected from <%= channel_name %>")
    this.isConnected = false

    // Create detailed disconnection error information
    const disconnectionError = {
      type: 'error',
      message: '<%= channel_name %> connection was disconnected',
      channel: '<%= channel_name %>',
      details: {
        connectionType: 'ActionCable WebSocket',
        event: 'disconnected',
        suggestion: 'Connection lost - check network or server status'
      }
    }
    this.handleGlobalError(disconnectionError)

    // Add your disconnection logic here
    this.onDisconnected()
  }

  private channelReceived(data: any): void {
    console.log("Received data:", data)

    // Restore any disabled buttons when receiving ActionCable messages
    if (typeof window.restoreButtonStates === 'function') {
      window.restoreButtonStates()
    }

    // Global error handling
    if (data.type === 'error' && data.success === false) {
      this.handleGlobalError(data)
      return
    }

    // üí° WEBSOCKET INTEGRATION - Handle real-time data here
    // TODO: Call this.displayMessage(data) for new messages
    // TODO: Update user lists, typing indicators, etc.

    // Handle different types of messages
    switch(data.type) {
<% actions.each do |action| %>
      case '<%= action %>':
        this.handle<%= action.camelize %>(data)
        break
<% end %>
      default:
        console.warn("Unknown message type:", data.type)
        this.handleUnknownMessage(data)
    }
  }

  // Override these methods in your implementation
  protected onConnected(): void {
    // Add your connection logic here
  }

  protected onDisconnected(): void {
    // Add your disconnection logic here
  }

  protected handleUnknownMessage(data: any): void {
    // Handle unknown message types
  }

<% actions.each do |action| %>
  // Send <%= action %> to server
  <%= action.camelize(:lower) %>(data: any = {}): void {
    if (!this.isConnected) {
      console.warn("<%= channel_name %> not connected, cannot perform <%= action %>")
      return
    }

    if (this.subscription) {
      this.subscription.perform('<%= action %>', data)
    }
  }

  // Handle <%= action %> message from server
  private handle<%= action.camelize %>(data: any): void {
    console.log('<%= action.camelize %> received:', data)
    this.on<%= action.camelize %>Received(data)
    this.dispatch('<%= action.dasherize %>-received', { detail: data })
  }

  // Override this method to handle <%= action %> messages from server
  protected on<%= action.camelize %>Received(data: any): void {
    // Add your <%= action %> handling logic here
  }

<% end %>
  // Global error handling for this channel
  private handleGlobalError(errorData: any): void {
    // Send to global error handler
    if (window.errorHandler && window.errorHandler.handleActionCableError) {
      window.errorHandler.handleActionCableError({
        ...errorData,
      })
    } else {
      // Fallback error handling
      console.error('Channel Error:', {
        ...errorData
      })
    }
  }

  // Check if WebSocket is connected
  get connected(): boolean {
    return this.isConnected
  }
}
