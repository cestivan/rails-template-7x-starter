import { Controller } from "@hotwired/stimulus"
import consumer from "../channels/consumer"
import Rails from "@rails/ujs"

/**
 * üèóÔ∏è <%= file_name.camelize %> Controller - Handles WebSocket + UI for <%= file_name.humanize.downcase %>
 *
 * ADD YOUR UI HERE:
 * - static targets = ["messageInput", "messagesContainer", "sendButton"]
 * - Add UI methods like sendMessage(), displayMessage()
 * - Use channelReceived() to handle real-time updates
 *
 * DON'T create separate controllers - extend this one!
 * HTML: <div data-controller="<%= file_name.dasherize %>">...</div>
 */
export default class extends Controller<HTMLElement> {
  static targets = [
    // üí° EXAMPLE: Common targets for your UI
    // "messageInput",     // <input data-<%= file_name.dasherize %>-target="messageInput">
    // "messagesContainer" // <div data-<%= file_name.dasherize %>-target="messagesContainer">
  ]

  static values = {
    // Add your values here, e.g.:
    // roomId: String,
    // userId: String
  }

  // Declare your targets and values
  // Must-having target
  // declare readonly messageInputTarget: HTMLInputElement
  // Optional target
  // declare readonly hasMessagesContainerTarget: HTMLElement
  // declare readonly messagesContainerTarget: HTMLElement
  // declare readonly roomIdValue: string

  private subscription: any = null
  private isConnected: boolean = false

  connect(): void {
    console.log("<%= file_name.camelize %> controller connected")
    this.createSubscription()
  }

  disconnect(): void {
    console.log("<%= file_name.camelize %> controller disconnected")
    this.destroySubscription()
  }

  // WebSocket subscription management
  private createSubscription(): void {
    if (this.subscription) return

    this.subscription = consumer.subscriptions.create(
      {
        channel: "<%= channel_name %>",
        // Add subscription parameters here, e.g.:
        // room_id: this.roomIdValue
      },
      {
        connected: this.channelConnected.bind(this),
        disconnected: this.channelDisconnected.bind(this),
        received: this.channelReceived.bind(this)
      }
    )
  }

  private destroySubscription(): void {
    if (this.subscription) {
      this.subscription.unsubscribe()
      this.subscription = null
      this.isConnected = false
    }
  }

  // WebSocket event handlers
  private channelConnected(): void {
    console.log("Connected to <%= channel_name %>")
    this.isConnected = true

    // Restore any disabled buttons when connecting
    if (typeof window.restoreButtonStates === 'function') {
      window.restoreButtonStates()
    }

    // Add your connection logic here
    this.onConnected()
  }

  private channelDisconnected(): void {
    console.log("Disconnected from <%= channel_name %>")
    this.isConnected = false

    // Create detailed disconnection error information
    const disconnectionError = {
      type: 'error',
      message: '<%= channel_name %> connection was disconnected',
      channel: '<%= channel_name %>',
      details: {
        connectionType: 'ActionCable WebSocket',
        event: 'disconnected',
        suggestion: 'Connection lost - check network or server status'
      }
    }
    this.reportError(disconnectionError)

    // Add your disconnection logic here
    this.onDisconnected()
  }

  private channelReceived(data: any): void {
    console.log("Received data:", data)

    // Restore any disabled buttons when receiving ActionCable messages
    if (typeof window.restoreButtonStates === 'function') {
      window.restoreButtonStates()
    }

    // Global error handling
    if (data.type === 'error' && data.success === false) {
      this.reportError(data)
      return
    }

    // Handle different types of messages
    switch(data.type) {
    // üì® EXAMPLE: Handle incoming message
    // case 'message':
    //   this.handleMessage(data)
    //   break
    // üìä EXAMPLE: Handle status update
    // case 'status_update':
    //   this.handleStatusUpdate(data)
    //   break
    default:
      console.warn("Unknown message type:", data.type)
      this.handleUnknownMessage(data)
    }
  }

  // Override these methods in your implementation
  protected onConnected(): void {
    // Add your connection logic here
  }

  protected onDisconnected(): void {
    // Add your disconnection logic here
  }

  protected handleUnknownMessage(data: any): void {
    // Handle unknown message types
  }

  // üéÆ ADD YOUR UI METHODS HERE
  // Example: data-action="click-><%= file_name.dasherize %>#sendMessage"
  // sendMessage(data: any = {}): void {
  //   if (!this.isConnected) return
  //   this.subscription?.perform('send_message', data)
  // }

  // üì§ EXAMPLE: Submit form data via Rails.ajax
  // submitForm(event: Event): void {
  //   event.preventDefault()
  //   const form = event.target as HTMLFormElement
  //
  //   Rails.ajax({
  //     type: form.method || 'POST',
  //     url: form.action,
  //     data: new FormData(form),
  //     success: (data: any) => {
  //       // Update UI after successful submission
  //       console.log('Form submitted successfully:', data)
  //     },
  //     error: (xhr: XMLHttpRequest) => {
  //       // Update UI to show error message
  //       console.error('Form submission failed:', xhr.responseText)
  //     }
  //   })
  // }

  // üìä EXAMPLE: Send status update to server
  // updateStatus(data: any = {}): void {
  //   if (!this.isConnected) return
  //   this.subscription?.perform('update_status', data)
  // }

  // üì® EXAMPLE: Handle message from server
  // üí° UI HELPER METHODS - Add methods to update your interface
  // private handleMessage(data: any): void {
  //   console.log('Message received:', data)
  //   TODO: Create message HTML element and add to container
  //   TODO: Scroll to bottom, update UI state
  // }

  // üìä EXAMPLE: Handle status update from server
  // private handleStatusUpdate(data: any): void {
  //   console.log('Status update received:', data)
  // }

  // Report error to error monitor
  private reportError(errorData: any): void {
    // Send to error monitor for display
    if (window.errorHandler && window.errorHandler.captureActionCableError) {
      window.errorHandler.captureActionCableError({
        ...errorData,
      })
    } else {
      // Fallback error logging
      console.error('Channel Error:', {
        ...errorData
      })
    }
  }

  // Check if WebSocket is connected
  get connected(): boolean {
    return this.isConnected
  }
}
