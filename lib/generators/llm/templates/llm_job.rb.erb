class LlmJob < ApplicationJob
  queue_as :llm

  # Retry strategy configuration
  retry_on Net::ReadTimeout, wait: 5.seconds, attempts: 3
  retry_on LlmService::TimeoutError, wait: 5.seconds, attempts: 3
  retry_on LlmService::ApiError, wait: 10.seconds, attempts: 2

  discard_on ActiveJob::DeserializationError

  def perform(prompt:, system: nil, options: {}, callback_class: nil)
    # Call LlmService - will use blocking mode since no block passed
    result = LlmService.call(
      prompt: prompt,
      system: system,
      **options.symbolize_keys
    )

    if result.success?
      # Execute callback if provided
      execute_callback(result, callback_class, error: nil) if callback_class
    else
      error = StandardError.new(result.error)
      execute_callback(result, callback_class, error: error) if callback_class
      raise error
    end

  rescue => e
    Rails.logger.error("LlmJob failed: #{e.class} - #{e.message}")
    execute_callback(nil, callback_class, error: e) if callback_class
    raise
  end

  private

  def execute_callback(result, callback_class_name, error: nil)
    return unless callback_class_name.present?

    begin
      callback_class = callback_class_name.constantize
      callback = callback_class.new(result, error)

      if callback.respond_to?(:call)
        callback.call
      elsif error && callback.respond_to?(:on_error)
        callback.on_error
      elsif !error && callback.respond_to?(:on_success)
        callback.on_success
      end
    rescue NameError => e
      Rails.logger.error("Callback class not found: #{callback_class_name} - #{e.message}")
      raise
    rescue => e
      Rails.logger.error("Callback execution failed: #{e.class} - #{e.message}")
      raise
    end
  end
end
