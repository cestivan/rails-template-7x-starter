class AdminCrudGenerator < Rails::Generators::NamedBase
  source_root File.expand_path('templates', __dir__)

  # Simple data structure to replace OpenStruct
  ModelAttribute = Struct.new(:name, :type, :sql_type, :null, :default, keyword_init: true)

  def check_model_exists
    unless model_class_exists?
      say "Error: Model '#{class_name}' does not exist.", :red
      say "Please create the model first using: rails generate model #{class_name} [field:type ...]", :yellow
      exit(1)
    end
  end

  def generate_controller
    template "controller.rb.erb", "app/controllers/admin/#{plural_name}_controller.rb"
  end

  def generate_views
    template "views/index.html.erb", "app/views/admin/#{plural_name}/index.html.erb"
    template "views/show.html.erb", "app/views/admin/#{plural_name}/show.html.erb"
    template "views/new.html.erb", "app/views/admin/#{plural_name}/new.html.erb"
    template "views/edit.html.erb", "app/views/admin/#{plural_name}/edit.html.erb"
  end

  def add_routes
    route "resources :#{plural_name}", namespace: :admin
  end

  def update_sidebar
    sidebar_path = "app/views/shared/admin/_sidebar.html.erb"
    if File.exist?(sidebar_path)
      sidebar_content = File.read(sidebar_path)
      
      # Check if menu item already exists
      generated_comment = "<!-- Generated by admin_crud: #{plural_name} -->"
      if sidebar_content.include?(generated_comment)
        say "Sidebar already contains #{humanized_plural_name} menu item, skipping...", :yellow
        return
      end
      
      # Add menu item to the end of the file
      menu_item = <<~MENU_ITEM

        #{generated_comment}
        <li>
          <%= link_to admin_#{plural_name}_path, 
              class: "\#{'active' if current_path.include?('/admin/#{plural_name}')}" do %>
            <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd"/>
            </svg>
            #{humanized_plural_name}
          <% end %>
        </li>
      MENU_ITEM
      
      updated_content = sidebar_content + menu_item
      File.write(sidebar_path, updated_content)
      say "Updated admin sidebar with #{humanized_plural_name} menu item", :green
    else
      say "Warning: Admin sidebar file not found. Please manually add menu item for #{humanized_plural_name}", :yellow
    end
  end

  private

  def model_class_exists?
    begin
      class_name.constantize
      true
    rescue NameError
      false
    end
  end

  def model_class
    @model_class ||= class_name.constantize
  end

  def singular_name
    name.underscore.singularize
  end

  def plural_name
    name.underscore.pluralize
  end

  def class_name
    name.classify
  end

  def humanized_name
    singular_name.humanize
  end

  def humanized_plural_name
    plural_name.humanize
  end

  def model_columns
    @model_columns ||= model_class.columns.reject do |column|
      # Skip system fields
      system_fields = %w[id created_at updated_at]
      
      # Skip sensitive fields
      sensitive_fields = %w[password_digest encrypted_password password_hash]
      
      # Skip fields ending with common sensitive patterns
      sensitive_patterns = %w[_digest _encrypted _hash _token _key]
      
      system_fields.include?(column.name) ||
      sensitive_fields.include?(column.name) ||
      sensitive_patterns.any? { |pattern| column.name.end_with?(pattern) }
    end
  end

  def model_attributes
    @model_attributes ||= model_columns.map do |column|
      ModelAttribute.new(
        name: column.name,
        type: column.type,
        sql_type: column.sql_type,
        null: column.null,
        default: column.default
      )
    end
  end

  def model_enums
    @model_enums ||= model_class.defined_enums
  end

  def model_associations
    @model_associations ||= model_class.reflect_on_all_associations(:belongs_to).map do |association|
      {
        name: association.name,
        class_name: association.class_name,
        foreign_key: association.foreign_key,
        optional: association.options[:optional]
      }
    end
  end

  def all_form_fields
    # Combine regular attributes, enums, and associations
    fields = []
    
    # Get lists of excluded field names
    foreign_keys = model_associations.map { |assoc| assoc[:foreign_key] }
    enum_names = model_enums.keys.map(&:to_s)
    
    # Add regular attributes (excluding foreign keys and enum fields)
    model_attributes.reject { |attr| 
      foreign_keys.include?(attr.name) || enum_names.include?(attr.name)
    }.each do |attr|
      fields << {
        name: attr.name,
        type: :attribute,
        attribute: attr
      }
    end
    
    # Add enum fields
    model_enums.each do |enum_name, _|
      fields << {
        name: enum_name.to_s,
        type: :enum,
        enum_name: enum_name,
        enum_values: model_class.send(enum_name.pluralize)
      }
    end
    
    # Add association fields
    model_associations.each do |assoc|
      fields << {
        name: assoc[:foreign_key],
        type: :association,
        association: assoc
      }
    end
    
    fields
  end

  def permit_params
    params = []
    
    # Get lists of excluded field names
    foreign_keys = model_associations.map { |assoc| assoc[:foreign_key] }
    enum_names = model_enums.keys.map(&:to_s)
    
    # Add regular attributes (excluding foreign keys and enum fields)
    model_attributes.reject { |attr| 
      foreign_keys.include?(attr.name) || enum_names.include?(attr.name)
    }.each do |attr|
      params << ":#{attr.name}"
    end
    
    # Add enum fields
    model_enums.each do |enum_name, _|
      params << ":#{enum_name}"
    end
    
    # Add association foreign keys
    model_associations.each do |assoc|
      params << ":#{assoc[:foreign_key]}"
    end
    
    params.uniq.join(', ')
  end

  def display_attributes
    # Return first few attributes for table display, prioritizing string/text fields
    attrs = model_attributes.select { |attr| %w[string text].include?(attr.type.to_s) }
    attrs = model_attributes if attrs.empty?
    attrs.first(3) # Limit to first 3 for table display
  end

  def display_fields
    # Return first few fields for table display, including attributes, enums, and associations
    fields = []
    foreign_keys = model_associations.map { |assoc| assoc[:foreign_key] }
    enum_names = model_enums.keys.map(&:to_s)
    
    # Add string/text attributes first (prioritize name-like fields)
    string_attrs = model_attributes.reject { |attr| 
      foreign_keys.include?(attr.name) || enum_names.include?(attr.name)
    }.select { |attr| %w[string text].include?(attr.type.to_s) }
    
    string_attrs.first(2).each do |attr|
      fields << { type: :attribute, attribute: attr }
    end
    
    # Add boolean attributes if we have space
    if fields.length < 4
      boolean_attrs = model_attributes.reject { |attr| 
        foreign_keys.include?(attr.name) || enum_names.include?(attr.name) ||
        fields.any? { |f| f[:type] == :attribute && f[:attribute].name == attr.name }
      }.select { |attr| attr.type.to_s == 'boolean' }
      
      boolean_attrs.first(4 - fields.length).each do |attr|
        fields << { type: :attribute, attribute: attr }
      end
    end
    
    # Add enums
    if fields.length < 4
      model_enums.keys.first(4 - fields.length).each do |enum_name|
        fields << { type: :enum, enum_name: enum_name, enum_values: model_class.send(enum_name.pluralize) }
      end
    end
    
    # Add associations if we still have space
    if fields.length < 4
      model_associations.first(4 - fields.length).each do |assoc|
        fields << { type: :association, association: assoc }
      end
    end
    
    # Fill remaining with any other attributes if needed
    if fields.length < 4
      remaining_attrs = model_attributes.reject { |attr| 
        foreign_keys.include?(attr.name) || enum_names.include?(attr.name) ||
        fields.any? { |f| f[:type] == :attribute && f[:attribute].name == attr.name }
      }
      remaining_attrs.first(4 - fields.length).each do |attr|
        fields << { type: :attribute, attribute: attr }
      end
    end
    
    fields
  end

  def form_field_for(attribute)
    case attribute.type.to_s
    when 'text'
      "text_area"
    when 'boolean'
      "check_box"
    when 'integer', 'decimal', 'float'
      "number_field"
    when 'date'
      "date_field"
    when 'datetime', 'timestamp'
      "datetime_local_field"
    when 'time'
      "time_field"
    else
      "text_field"
    end
  end

  def form_field_for_enum(enum_name, enum_values)
    "select"
  end

  def form_field_for_association(association)
    "select"
  end

  def enum_options_for_select(enum_name, enum_values)
    enum_values.map { |key, value| [key.humanize, key] }
  end

  def association_options_method(association)
    klass = association[:class_name].constantize
    if klass.respond_to?(:name) && klass.column_names.include?('name')
      "#{association[:class_name]}.all.map { |item| [item.name, item.id] }"
    elsif klass.respond_to?(:title) && klass.column_names.include?('title')
      "#{association[:class_name]}.all.map { |item| [item.title, item.id] }"
    elsif klass.respond_to?(:email) && klass.column_names.include?('email')
      "#{association[:class_name]}.all.map { |item| [item.email, item.id] }"
    else
      "#{association[:class_name]}.all.map { |item| [item.id, item.id] }"
    end
  end

  def input_class_for(attribute)
    case attribute.type.to_s
    when 'text'
      "textarea"
    when 'boolean'
      "checkbox"
    else
      "input"
    end
  end

  def display_value_for(attribute, instance_var)
    case attribute.type.to_s
    when 'text'
      "simple_format(#{instance_var}.#{attribute.name})"
    when 'boolean'
      "#{instance_var}.#{attribute.name} ? 'Yes' : 'No'"
    when 'date', 'datetime', 'timestamp'
      "#{instance_var}.#{attribute.name}&.strftime('%Y-%m-%d %H:%M')"
    else
      "#{instance_var}.#{attribute.name}"
    end
  end

  def display_value_for_enum(enum_name, instance_var)
    "#{instance_var}.#{enum_name}&.humanize"
  end

  def display_value_for_association(association, instance_var)
    assoc_name = association[:name]
    klass = association[:class_name].constantize rescue nil
    
    if klass && klass.column_names.include?('name')
      "#{instance_var}.#{assoc_name}&.name"
    elsif klass && klass.column_names.include?('title')
      "#{instance_var}.#{assoc_name}&.title"
    elsif klass && klass.column_names.include?('email')
      "#{instance_var}.#{assoc_name}&.email"
    else
      "#{instance_var}.#{assoc_name}&.id"
    end
  end

  def truncate_value_for(attribute, instance_var)
    case attribute.type.to_s
    when 'text'
      "truncate(#{instance_var}.#{attribute.name}, length: 100)"
    when 'boolean'
      "content_tag(:span, (#{instance_var}.#{attribute.name} ? 'Yes' : 'No'), class: \"badge \" + (#{instance_var}.#{attribute.name} ? 'badge-success' : 'badge-error'))"
    else
      "#{instance_var}.#{attribute.name}"
    end
  end

  def truncate_value_for_enum(enum_name, instance_var)
    "#{instance_var}.#{enum_name}&.humanize"
  end

  def truncate_value_for_association(association, instance_var)
    display_value_for_association(association, instance_var)
  end

  def attribute_required?(attribute)
    # Check model validations for presence requirement
    model_class.validators_on(attribute.name.to_sym).any? do |validator|
      validator.is_a?(ActiveModel::Validations::PresenceValidator)
    end
  end

  def get_validation_info(attribute)
    # Get validation information for better form generation
    validators = model_class.validators_on(attribute.name.to_sym)
    info = {
      required: false,
      length_max: nil,
      length_min: nil,
      format: nil
    }
    
    validators.each do |validator|
      case validator
      when ActiveModel::Validations::PresenceValidator
        info[:required] = true
      when ActiveModel::Validations::LengthValidator
        info[:length_max] = validator.options[:maximum] if validator.options[:maximum]
        info[:length_min] = validator.options[:minimum] if validator.options[:minimum]
      when ActiveModel::Validations::FormatValidator
        info[:format] = validator.options[:with] if validator.options[:with]
      end
    end
    
    info
  end
end
